###Introduction

推荐材料

Introduction to Algorithms

### 数学基础

函数集合

1. 同阶函数集合

   给定两个单元多项式判断两个式子对应

### 分治算法

1. Divide:划分子问题

   D(n)

2. conquer：求解子问题

   时间：T(n/b)

3. combine：合并子问题解，形成原始问题解

   C(n)

#### 实例

- 归并排序


- 求集合最大元素

  T(n) = T(n/2)+1

  1. 序列划分为两半
  2. 对每一半

- 最大值最小值问题

  能从时间复杂度：O(2n)—> O(3n/2)

  - 划分序列的同时，求最大值最小值
  - 两个指针，a,b , 指向头部首尾，向中间移动，比较小的放前面，大的放后面

- $X^n$

- 整数乘法

  输入n 位二进制整数 X Y,输出X和Y 的乘积

  分治

  O(n^2) —> $O(n^{log_23})$

- 矩阵乘法

- 空间中距离最近的点

- 凸包(convex hull)

  给定空间的点，找到点构成边界包含所有点

  - 算法1： 从空间内任选3个点，删除这3个点构成的三角形内的点

  - 算法2： 算法1 的时间复杂度是 $n^4$ ,优化，选定一个确定在凸包边界的点，很明显x 最小，x 最大，y最小，y最大，必在边界上

  - 算法3：想要不断的找到边界的点，在算法2 的基础上，找到一个确定的p 点

    1. 根据 点 m，p 与水平的夹角排序
    2. 根据夹角由小到大，不断判断
    3. 递归判断之前的点

    > 循环不变量

  - 算法4： 使用分治算法避免排序

    1. 通过将平面的点划分为两个子部分

  - 证明 凸包问题 时间复杂度不能 小于 nlogn

    反证法: 使用 y =x^2 函数  ,给定 (x1,x1^2)…..,算法需要 由最小点 x1 到 最大 x n 输出 本身就是一个排序问题

- 剪枝搜索：

  典型问题是：选择第K 大的元素

  ​

### 动态规划

***

#### 思想介绍

1. 将问题转化为子问题
   - 问题独立：分治
   - 问题相互关联：动态规划
2. 将子问题的解存储起来

举例： 斐波那契数列， f(n) = f(n-1)+f(n-2),f(0) = f(1)=1

算法1： 分治思想，从后往前算，要计算 f(n) 

算法2：存储中间值，算法复杂度是指数时间，==为什么？== 输入 $log_2n$ 

> 刚才举了个矩阵乘法的问题是线性时间



#### 最长公共子序列(LCS)

**问题定义:**求解两个序列的最长公共子序列的长度

> 子序列的定义：序列a 中所有元素在序列b 中按顺序存在，说a 是b 的子序列

1. 先想怎么求解：Brute-Force 做法

   对于序列a，b 选择短的序列，穷举b 的所有可能子序列，扫描a中



**递归方程设计**

2. 使用递归方法解

3. 使用动态规划的方式减少计算

   - 动态规划方程

   - 寻找子序列构造路径矩阵 $B_{ij}$

     递归打印

####矩阵乘法实现

- 分治法

  把问题划分子问题

  给出最优的递归方程

####背包问题

问题：给定 n种物品和一个背包，物品 i的重量是 w i ，价值v 价值 v i , 背包承重为C 背包承重为 C, 问如何选择装入背 包的物品， 包的物品 ，使装入背包中的物品的总价值最 大？(注：物品不能切割，只能完全装入)

1. 处理成子问题：

   用 $x_i =\{0,1\}$ 表示取不取这个物品 

   假设对第1件物品分析两种情况

   - ​
   - 那子问题就是物品为2~n，承重C-w1



### 贪心算法

***

算法思想：一个问题的最优解包含子问题的最优解，能用 贪心选择+ 优化子结构 构造得到

> 回想梯度下降的思想



####贪心算法 vs 动态规划

- 动态规划
  1. 即
- 贪心算法：优化子结构和每一步进行的贪心选择不相关，局部最小就能构造全局最小

#### 活动选择问题

- 问题定义
- 算法分析
  - 解法
  - 最优解证明


==考察贪心选择性（证明）==