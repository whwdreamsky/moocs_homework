# 人工智能

> 2018年01月07日17:56:49 

### 搜索算法

- 状态空间，解空间

  八数码示例


- 无信息搜索

  也叫盲目搜索，不借助知识

  - 广度优先

    - 完备性:能找到最优解
    - 内存消耗大

  - 一致代价搜索：

  - 深度优先：

    - 可能得到的不是最优解
    - 内存需求少
    - 在树中深度优先是**优先选择最左侧的节点**，在图中选择**任一未被访问过的节点**，如果该节点没有未被访问过的节点则退一个节点
    - 迭代加深的深度优先搜索(Iterative-Deepening-Search) : 是带深度上界的深度优先搜索，结合广度优先和深度优先，不断的增加深度搜索的限制

  - 双向搜索：

    一方从初始状态搜索，一方从目标状态搜索，当两方相遇停止搜索

  ==TODO==： 一致搜索，深度优先搜索，贪心最优搜索，广度优先搜索，启发式搜索，考察之间的关系

- 启发式搜索

  - ==a* 算法==，解决静态图的最短路搜索，是基于BFS(广度优先搜索)的启发式算法

    a* 其实是**加入启发函数的BFS**，启发函数是$f(n) = g(n)+h(n)$,其中f(n) 表示经过点n的预计耗散，g(n) 从出发点到n 的耗散，h(n) 是启发式的是n点到目标节点的耗散估计值，根据公式我们知道当h(n) 为0 是一致性搜索，即只考虑g(n)

  - a * 解决 八数码问题

    - 问题形式化定义

      状态：状态描述了8个棋子和空位在棋盘的9个方格上的分布。

      初始状态：任何状态都可以被指定为初始状态。

      操作符：用来产生4个行动（上下左右移动）。

      目标测试：用来检测状态是否能匹配上图的目标布局。

      路径费用函数：每一步的费用为1，因此整个路径的费用是路径中的步数。

      现在任意给定一个初始状态，要求找到一种搜索策略，用尽可能少的步数得到上图的目标状态

    - f(n) 构建

    - 数据结构设计

      -  closed 表：使用hash 记录已经访问过的节点，同时记录搜索路径，当访问扩展到访问的节点就不加入Open 表
      -  open 表：保存所有待扩展节点，生成但未访问过的，根据f(n),每次从open表中扩展一个节点
      -  Tree 节点: 需要包含 父节点，子节点，当前的状态，耗散值

    - 算法流程：

      1. 把初始状态节点存入优先级队列open
      2. 从优先级队列中选择一个最优节点A，进行扩展，得到k 个状态，将A 加入到Close 表中(代表已经访问过)
      3. 对k 个状态中每个状态$k_i$，进行判断，是否已经在优先级队列中，如果在进入4，如果不在进入5
      4. 比较同一状态下耗散f 的值，如果优先级队列中的耗散f较当前$f_{k_i}$大，从优先级队列中删除这个元素，否则，从带插入的k 个状态中删除这个状态
      5. 判断$k_i$是否出现在close 表中，如果没有存入则加入到优先级队列open 中。
      6. 回到3直到所有子状态判断完成
      7. 直到优先级队列中没有元素程序结束。

    - 伪代码如下

    ~~~c++
    A*(START,END)
    {
        // 第一步加入初始节点
    	OPEN.Add(start);
    	// 待扩展节点队列非空
    	while(!OPEN.empty())
    	{
            //这个优先级队列是在BFS基础上加入启发函数
    		S = OPEN.pop(); // 从OPEN表中弹出一个最优的待扩展节点
    		CLOSED.Add(起始节点); // 置入CLOSED表
    		// 如果S就是目标状态则结束
    		if(S == GOAL)
    		{
    			return OVER;
    		}
    		// 尝试扩展S的所有子节点
    		while(childS = S.nextChild())
    		{
    			// 考察子节点是否在OPEN表内
    			if(OPEN.isInclude(childS))
    			{
    				// 如果这个子节点比OPEN表内的节点更优
    				if(g(childS) < g(OPEN.Find(childS))
    				{
    					// 把这个之前扩展过的子节点的父节点修正为S
                        // 这里也可以直接把旧的节点删除，为的是当有相同状态的节点时保留f 小的
    					childS.parent = S; 
    				}
    			}
    		// 通过CLOSED表判重
    			if(!CLOSED.isInclude(childS))
    			{
    				// 如果没扩展过这个节点则把这个节点加OPEN中
    				OPEN.Add(childS);
    			}
    		}
    	}
      }
    ~~~

    ​

    八数码问题 实战 http://blueve.me/archives/684

    http://blog.csdn.net/mulinb/article/details/5932097

- 局部搜索

- 博弈搜索

  - 极大极小决策：Max ，Min ，代表博弈双方，一方的决策参考**下一步**让另一方最差的方法

    深度优先

  - 博弈树的生成

  - $ \alpha - \beta$ 剪枝

    ![prune](/Users/oliver/Desktop/AI_photo/5.1.png)

    从这里看到了使用极大极小策略生成博弈树，并进行剪枝的过程，这里可以看到，算法没有对节点C的所有节点访问，只是对第一个节点(2) 访问就停止了，首先第一层是开始阶段，第二层是Max 有(B,C,D)三种选择，第三层是假设Max 选择了某个节点，Min 可能的取值导致的场面上的值，假设Max 选了B， 同时假设Min 去了 B 的后继中最小的3 这个值，所以B 节点取值就为3，假设Max 选 C ， 后继节点第一个就为2 ，因此Min 最差也能选到2，因为之前B 取值3 > 2 ,所以不用继续查看C 后继的取值，这就是**$\boldsymbol {\alpha - \beta} $**剪枝

    习题:

    ![prune](/Users/oliver/Desktop/AI_photo/5.2.png)


### 知识表示

给实例给出实体等

产生式系统表示语义：



框架规则表示语义：

### 不确定推理

#### 完全联合分布

自己的理解也就是边缘概率$P(A) = \sum_zP(A|Z)$,在条件Z下，所有A 命题成立的之和就是A 的概率

举例：

目的：cavity 表示有洞的,也就是一个属性，toothache 是牙痛这一结果，我们想知道在牙痛的观测结果下推断原因是cavity 的概率（其实也就是bayes基本问题），P(cavity|toothache)

根据乘法原理我们可以得到$P(cavity|toothache) = $

我们相对P(A|B) 



###贝叶斯学习

####贝叶斯基础知识

贝叶斯公式: 往往我们是给定观察属性B，要求求解类别 A 的概率，
$$
P(A|B)=\frac{P(B|A) \cdot P(A)}{P(B)}
$$


#### 朴素贝叶斯



贝叶斯假设：P(A 1 , A 2 , …, A n |C j ) = P(A 1 | C j ) P(A 2 | C j )… P(A n | C j )

####贝叶斯网络

不确定下进行推理的网络模型

##### 贝叶斯网的近似推理



吉布斯采样算法



### 课程结束后的思考

首先觉得自己这门课程学的不好，第一，对自己要求不高，没有把功夫用到平时，第二，对新的知识有一种抵触情绪，这对程序员是非常不利的，第三，懒，不想去动手实践, 但是 好的一方面，认识到规格严格的标准，直到周围人的水准，认识到学了不用或者不进行最基本的实践

### 参考

https://clyyuanzi.gitbooks.io/julymlnotes/content/nb.html

Pattern Recognition and Machine Learning 